#!/usr/bin/env perl

use FindBin qw($Bin);

use lib "$Bin/../lib";

# To capture output from *stat commands
package PA::Capture::Stat;







# To capture output from DTrace scripts
package PA::Capture::DTrace;

use v5.20;

use Moose;
use MooseX::Types::Moose qw(Str Int Undef HashRef ArrayRef);
use Moose::Util::TypeConstraints;
use namespace::autoclean;
use Solaris::kstat;
use IO::Async::Loop;
use Future;
use Data::Dumper;
use PA::AMQP::Client;


with 'MooseX::Log::Log4perl';







package PA::Capture::kstat;

use v5.20;

use Moose;
use MooseX::Types::Moose qw(Str Int Undef HashRef ArrayRef);
use Moose::Util::TypeConstraints;
use namespace::autoclean;
use Solaris::kstat;
use IO::Async::Loop;
use IO::Async::Timer::Periodic;
use Future;
use Data::Dumper;
use PA::AMQP::Client;

with 'MooseX::Log::Log4perl';

#############################################################################
# Attributes
#############################################################################

has [ 'client' ] => (
  is       => 'ro',
  isa      => 'PA::AMQP::Client',
  required => 1,
);

has [ 'loop' ] => (
  is       => 'ro',
  isa      => 'IO::Async::Loop',
  default  => sub {
                say "BUILDING PA::Capture::kstat loop";
                return IO::Async::Loop->new;
              },
);

has [ 'kstat' ] => (
  is       => 'ro',
  isa      => 'Solaris::kstat',
  default  => sub {
                say "BUILDING kstat";
                return Solaris::kstat->new;
              },
);

has [ 'kstats_to_collect' ] => (
  is       => 'ro',
  isa      => ArrayRef[ ArrayRef ],
  default  => sub {
                [
                  [ "unix", 0, "system_pages" ],
                ];
              },
);


has [ 'timer' ] => (
  is       => 'ro',
  isa      => 'IO::Async::Timer::Periodic',
  builder  => '_build_timer',
  lazy     => 1,
);


sub _build_timer {
  my ($self) = @_;

  say "BUILDING TIMER";
  my ($k)                 = $self->kstat;
  my ($loop)              = $self->loop;
  my ($client)            = $self->client;
  my (@kstats_to_collect) = @{$self->kstats_to_collect};

  my $timer = IO::Async::Timer::Periodic->new(
    interval => 1,
    on_tick  => sub {
      $k->update;
      my $latest_k = $k->copy;
      my @futures;

      foreach my $kstat_def (@kstats_to_collect) {
        my ($module, $instance, $name) = @$kstat_def;
        push @futures,
          Future->wrap(
              { name =>  $name,
                stats => capture_kstat($latest_k, $module, $instance, $name)
              }
          );
      }

      my $kstat_future =
        Future->wait_all(
          @futures
        );
      $kstat_future->on_done(
        sub {
          my (@done_futures) = @_;
          my (@publish_futures);
          foreach my $done_future (@done_futures) {
            my ($stat_name)  = $done_future->get->{name};
            my ($stat_stats) = $done_future->get->{stats};
            #say Dumper( $done_future->get );
            my ($routing_key) = $client->client_hostname . ".$stat_name";
            push @publish_futures, $client->send($routing_key, $stat_stats);
          }
          # Wait for all of the publishing futures to complete
          my $publishing_future = Future->wait_all( @publish_futures );
          $publishing_future->get;
        }
      );
    },
  );

  $timer->start;
  $loop->add($timer);

  return $timer;
}

sub BUILD {
  my ($self) = @_;

  say "Building client";
  $self->client;
  say "Building loop";
  $self->loop;
  say "Building kstat";
  my ($k) = $self->kstat;
  say "Initializing kstats to collect";
  my (@kstats_to_collect) = @{$self->kstats_to_collect};
  foreach my $kstat_def (@kstats_to_collect) {
    my ($module,$instance,$name) = @$kstat_def;
    () = each %{$k->{$module}->{$instance}->{$name}};
  }
  say "Building timer";
  $self->timer;
}

sub capture_kstat {
  my ($k, $module, $instance, $name) = @_;

  my ($outdata);
  # Filter out the non-numeric values (class => misc, for instance)
  my %keep = map{ $_ => $k->{$module}{$instance}{$name}{$_}  }
             grep { $k->{$module}{$instance}{$name}{$_} !~ m/\D/; }
             keys %{$k->{$module}{$instance}{$name}};

  $outdata = \%keep;
  $outdata->{timestamp} = DateTime->now( time_zone => 'UTC' )->epoch;

  return $outdata;
}


package main;
use v5.20;
use strict;
use warnings;

use Getopt::Long;
use JSON::MaybeXS;
use DateTime::TimeZone   qw();
use Net::Async::AMQP;
use IO::Async::Loop;
use Data::Dumper;
use PA::AMQP::Client;
use PA::Capture::kstat;
use FindBin qw($Bin);

use lib "$Bin/../lib";

# This spike shows how PA clients starting up will initially post host specific
# information, so that it can be received and pre-inserted into the back end
# database before the host begins to send information.

my %client_ctor_args;
my $amqp_server;

my $kstats_to_collect =
  [
    [ qw( unix    0      system_pages) ],
    [ qw( unix    0      dnlcstats) ],
    [ qw( zfs     0      arcstats) ],
  ];

GetOptions( "amqp=s" => \$amqp_server )
  or die("ERROR in command line args");

if ($amqp_server) {
  $client_ctor_args{amqp_server} = $amqp_server;
}

my $loop = IO::Async::Loop->new();
$client_ctor_args{loop} = $loop;

my $client = PA::AMQP::Client->new( %client_ctor_args );
my $kstats = PA::Capture::kstat->new(
  # TODO: Don't need loop if we've got client with loop within it
  loop              => $loop,
  client            => $client,
  kstats_to_collect => $kstats_to_collect,
);
#my $vmstat = PA::Capture::vmstat->new();
#my $dtrace = PA::Capture::DTrace->new();

say "AMQP SERVER: " . $client->amqp_server;
$loop->run();



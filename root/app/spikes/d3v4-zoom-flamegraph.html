<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>D3 v4 Flamegraph Test</title>

  <style>
    .chart {
      background:    lightgray;
      border:        1px solid black;
      min-width:      768px;
      min-height:     768px;
    }
    .stack-text {
      font-family:    "Verdana";
      font-size:      12px;
      pointer-events: none;
      /* The following goes with the d3-flame-graph foreignObject concept */
      /*white-space:    nowrap;*/
      /*text-overflow:  ellipsis;*/
      /*overflow:       hidden;*/
      /*text-align:     left;*/
    }
  </style>
</head>
<body>

  <div class="chart"></div>

  <!-- D3 v4 -->
  <script type="text/javascript" src="../../bower_components/d3/d3.min.js"></script>
  <script type="text/javascript" src="../../bower_components/lodash/dist/lodash.min.js"></script>

  <!-- and our Javascript spike for Flame Graph -->
  <script type="text/javascript">

    // 18 pixel bottom margin to make room for informational banner
    var margin = { top: 0, right: 0, bottom: 18, left: 0 };

    // Font related constants
    var fontsize    =   12,
        fontwidth   =   0.59; // Average width relative to fontsize

    var  width      =  768 - margin.left - margin.right;
    var height      =  768 - margin.top - margin.bottom;
    var cell_height =   18;
    var sort        =  true;

    var xScale = d3.scaleLinear().range([0, width]),
        yScale = d3.scaleLinear().range([0, cell_height]);

    // Total value of all stack samples in root node
    var totalValue;
    var root;

    display_chart();

    function update(data) {
      console.log(data);

      root = d3.hierarchy(data)
          .sort(true)
          .sum(function (d) { return d.children ? 0 : d.value; })
        ;

      // Put a unique ID on each datum for ease of selection later
      root.each(
        function(node) {
          node.data.uniqueID = makeId();
        }
      );

      var partition = d3.partition()
        // This implicitly scales x0,y0,x1,y1
        .size([width, height])
        .padding(0);

      partition(root);

      console.log(root.data);

      // We can now determine the proper scale domain(s)
      // xScale.domain([0, d3.max(root.children, function(root) { return root.data.value; })]).nice();
      console.log("X Domain MAX:" + root.data.value);
      // xScale.domain([0, width]);
      xScale.domain([0, root.data.value]);

      // we can now determine the total value of the root node
      totalValue = root.data.value;
      console.log("totalValue: " + totalValue);

      var svg = d3.select('.chart')
        .append('svg')
          // properly size the svg element to contain elems
        .attr('width', width + margin.left + margin.right)
        .attr('height', height + margin.top + margin.bottom);

      var g_container =
        svg
          .append('g')
          .attr('transform','translate(' + margin.left + ',' + margin.top + ')');

      var banner_container =
        svg
          .append('g')
            .attr('transform','translate(0,' + (height) + ')')
            .attr("id", "banner_container")
          .append('rect')
            .attr("id", "banner_rect")
            .attr('fill', 'skyblue')
            .attr('stroke', 'green')
            .attr('x', 0)
            .attr('y', 0)
            .attr("height", cell_height)
            .attr("width",  width)
        ;

      // background_gradient(g_container, bgcolor1, bgcolor2, width, height);

      var bars = g_container
        .selectAll('g')
        .data(root.descendants())
        .enter()
        .append('g')
          .attr('transform',
            function (d, i) {
              console.log(d, this);
              // console.log("BARS: d.x0: " + d.x0 + ", scaled d.x0: " + xScale(d.x0) );
              return 'translate(' + d.x0 + ',' +
                     (height - yScale(d.depth) - cell_height) + ')';
            }
          )
          .attr("id", function(d) { return d.data.uniqueID; } )
          .on('click',  nodeZoom);


      var nodes = bars
        .append('rect')
        .attr('fill', function(d) {
          return 'yellow'; // color(color_theme);
        })
        .attr('stroke', 'black')
        .attr("x", function(d) { return 0; })
        .attr("y", function(d) { return 0; })
        .attr("height", function(d) { return cell_height; })
        .attr("width", function(d) { // return xScale(d.x1 - d.x0);
                                     return (d.x1 - d.x0);})
        .on('mouseover',nodeMouseOver)
        .on('mouseout', nodeMouseOut);

      bars.append('text')
        .text(function(d,i) {
          var final_text_str;
          // Select the previous sibling rect for this text
           var rect = d3.select(this.previousSibling);
           var rect_width = rect.attr("width");

          var text_str = d.data.name;
          // how many characters will fit in the rect's available width?
          var chars_that_will_fit = rect_width / (fontsize * fontwidth);

          if (rect_width < (2 * fontsize * fontwidth)) {
            // nothing will fit
            final_text_str = "";
          } else if (text_str.length > chars_that_will_fit) {
            // Just print what fits with a trailing ellipsis
            final_text_str = text_str.substring(0,chars_that_will_fit - 2) + "..";
          } else {
            // the whole string fits, no problem
            final_text_str = text_str;
          }

          return final_text_str;
        })
        .attr('y', cell_height - 3)
        .attr('x', 3)
        .attr("class", "stack-text");
    }



    function display_chart() {
      var chart_data =
          {
            "name": "all",
            "value": 1200,
            "children": [
              {
                "name": "level1-1-100",
                "value": 1200,
                "children": [
                  {
                    "name": "level2-1-50",
                    "value": 600,
                    "children": [
                      {
                        "name": "level3-1-25",
                        "value": 300
                      },
                      {
                        "name": "level3-2-25",
                        "value": 300
                      }
                    ]
                  },
                  {
                    "name": "level2-2-50",
                    "value": 600,
                    "children": [
                      {
                        "name": "level3-1-33",
                        "value": 200
                      },
                      {
                        "name": "level3-2-33",
                        "value": 200
                      },
                      {
                        "name": "level3-3-33",
                        "value": 200
                      }
                    ]
                  }
                ]
              }
            ]
          };

      // Eliminate existing SVG, if any

      d3.select('svg').remove();
      update(chart_data);
//      d3.json(chart_data, function (error, data) {
//        if (error) return console.warn("WE DIED: " + error);
//        // console.log(data);
//        update(data);
//      });
    }

    function nodeZoom(datum, index, nodes) {
      console.log("THIS:");
      console.log(this);
      console.log(datum);

      // Get the current X of the g element for the node being zoomed
      var zoomedNode_g = d3.select("#" + datum.data.uniqueID);
      var zoomedNode_g_currentX = zoomedNode_g.node().transform.baseVal[0].matrix.e;
      console.log("zoomedNode_g_currentX: " + zoomedNode_g_currentX);

      // squirrel away DOM element 'this' for later use
      var dom_g = this;

      var ancestors = datum.ancestors();
      // Get entire array, in order
      // TODO: We really only need the non-ancestor elements that are above
      //       the node being Zoomed
      var root_array = root.descendants();
      // console.log(root_array);

      console.log("ANCESTORS:");
      ancestors.forEach(
        function (node, i) {
          if (i == 0) { return; }
          console.log(node.data.name);
        }
      );
      console.log(ancestors);

      var descendants = datum.descendants();


      // Hide siblings
      var siblings = getSiblings(datum);
      console.log("SIBLINGS:");
      siblings.forEach(
        function (node, i) {
          console.log(node.data.name);
          console.log("UNIQUE ID:", node.data.uniqueID);

          // Disappear each sibling
          d3
            .select("#" + node.data.uniqueID)
            .selectAll("*")
            .classed("hidden","true");
        }
      );
      //
      // Also need to hide any nodes that are "above" this one
      // (depth is < this node's depth), AND aren't an ancestor of this node.
      // start with root, and traverse descendants, capturing all until we hit this depth.
      // then use lodash to subtract the list of ancestors from this list
      // then mark whatever is left as hidden.
      var non_ancestors_above =
        _.filter(root_array,
                 function (value, index, collection) { return value.depth < datum.depth; });
      non_ancestors_above = _.difference(non_ancestors_above,ancestors);

      console.log("NON-ANCESTORS ABOVE NODE:");
      console.log(non_ancestors_above);

      non_ancestors_above.forEach(
        function (node, i) {
          console.log(node.data.name);
          console.log("UNIQUE ID:", node.data.uniqueID);

          // Disappear each entity
          d3
            .select("#" + node.data.uniqueID)
            .selectAll("*")
            .classed("hidden","true");
        }
      );

      // Hide nodes "below" this node, which aren't a descendant of it
      var non_descendants_below =
        _.filter(root_array,
                 function (value, index, collection) { return value.depth > datum.depth; });
      non_descendants_below = _.difference(non_descendants_below, descendants);

      non_descendants_below.forEach(
        function (node, i) {
          console.log(node.data.name);
          console.log("UNIQUE ID:", node.data.uniqueID);

          // Disappear each entity
          d3
            .select("#" + node.data.uniqueID)
            .selectAll("*")
            .classed("hidden","true");
        }
      );

      // Now fade out our ancestors
      ancestors.forEach(
        function (node, i) {
          if (i == 0) { return; }
          d3
            .select("#" + node.data.uniqueID)
            .selectAll("*")
            .classed("fade", "true");
        }
      );

      // Get the scaling factor, so we know what to scale the
      // descendants by
      // NOTE: Can also use the rect's width, should it come to that, but that would
      //       require selecting it.
      var multiplyFactor = width / (datum.x1 - datum.x0);
      console.log("MULTIPLY FACTOR: " + multiplyFactor);

      // Scale ancestors to 100%, if they aren't already
      // We get the zoomed node included for free in ancestors
      ancestors.forEach(
        function (node, i) {
          var g = d3.select("#" + node.data.uniqueID);
          // http://stackoverflow.com/questions/38224875/replacing-d3-transform-in-d3-v4
          // console.log("TRANSFORM");
          // console.log(g.node().transform.baseVal[0].matrix.f);
          var currentY = g.node().transform.baseVal[0].matrix.f;

          // Translate g to far left, same height
          g.attr('transform', 'translate(0,' + currentY + ')');
          // Set rect width to entire width
          g.select('rect')
            .attr("width",width);

          // TODO: Text elements can become long enough to see, expand them
        }
      );

      // Scale the descendants
      // Calculation is: (child_g_currentX - zoomedNode_g_currentX) * multiplyFactor
      descendants.forEach(
        function (node, i) {
          if (i == 0) { return; }  // Don't alter the zoomed node itself
          var g = d3.select("#" + node.data.uniqueID);
          var currentX = g.node().transform.baseVal[0].matrix.e;
          var currentY = g.node().transform.baseVal[0].matrix.f;

          // Translate g to currentX / multiplyFactor
          g.attr('transform', 'translate(' + ((currentX - zoomedNode_g_currentX) * multiplyFactor) + ',' + currentY + ')');

          // Expand rect width * multiplyFactor
          var current_width =
            g.select('rect')
              .attr("width");
          g.select('rect')
            .attr("width", current_width * multiplyFactor);
        }
      );

    }

    function makeId(prefix) {
      // HTML id's must begin with a letter of some sort
      prefix || (prefix = 'X');
      return prefix + (Math.random() * 1e16).toFixed(0);
    }

  </script>



</body>
</html>
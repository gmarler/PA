<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>D3 FS Operations Heatmap Spike</title>
</head>

<style>
  body {
    font:    10px sans-serif;
  }

  .label {
    font-weight: bold;
  }

  .tile {
    shape-rendering: crispEdges;
  }

  .axis path,
  .axis line {
    fill:            none;
    stroke:          #000;
    shape-rendering: crispEdges;
  }
</style>
<body>

<script src="../../bower_components/d3/d3.min.js"></script>
<script src="../../bower_components/lodash/lodash.min.js"></script>
<script src="../../bower_components/moment/moment.js"></script>

<script>

var margin = {
  top:    20,
  right:  90,
  bottom: 30,
  left:   50
};

var width  = 960 - margin.left - margin.right;
var height = 700 - margin.top  - margin.bottom;

var xAxisScale = d3.time.scale().range([0, width]);
var yAxisScale = d3.scale.linear().range([height,0]);
var colorScale = d3.scale.linear().range(["white", "steelblue"]);

// Size of the buckets (constant for now, with test data)
var xStep = 31;
var yStep = 900;



var svg = d3.select("body").append("svg")
    .attr("width", width + margin.left + margin.right)
    .attr("height", height + margin.top + margin.bottom)
    .append("g")
    .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

var xAxis = d3.svg.axis()
    .scale(xAxisScale)
    .orient("bottom")
    .ticks(20)
    .tickFormat(d3.time.format("%Y-%m-%d %X"));

d3.json("../../data/iolat_heatmap_data.json", function(error, data) {
  if (error) return console.warn(error);
  // Data is in form:
  // [
  //   { timestamp: <seconds in UTC>,
  //     interval_data: [
  //       {
  //         "getpage:tmpfs":[[[10000,10999],1],[[12000,12999],1]],
  //       }
  //     ]
  //   },
  //   ...
  // ]
  //
  // Note that the DTrace that collects this data does so with the following llquantize() parameters:
  // llquantize(foo, 10, 3, 11, 100)
  // BASE/FACTOR: 10
  // LOW EXPONENT: 3
  // HIGH EXPONENT: 11
  // STEP:          100
  // Which will quantize from 10^3 through 10^12 - 1, with each range having 100 steps
  // So that's a possible range of 9 orders of magnitude, with 100 steps each, so our heatmap
  // could be, at most, 900 rectangles tall per time interval.
  //
  var intervals = [];
  data.forEach(function(interval) {
    var itimestamp = interval.timestamp;
    var interval_data = interval.interval_data;
    var current_interval = {};
    interval_data.forEach(function(fsop_fstype_data) {
      Object.keys(fsop_fstype_data).forEach(function(key) {
        // key is the fsop:fstype
        // console.log(key);
        // The value is an array of latency ranges, each composed of a start/end range, and a count
        // We will eventually determine which fsop/fstype we care about, and only aggregate those
        // Data Extent:
        // minimum latency among all timestamps being considered
        // maximum latency among all timestamps being considered
        // Based on the llquantize() parameters above, this will give us an extent of (even if the
        // data is sparse, which it always should be) max exponent - min exponent * 100
        // To begin, we'll just use 9 * 100 as a constant
        fsop_fstype_data[key].forEach(function(lat_array) {
          // new_key: [ low bound, upper bound ]
          // WARNING: This converts into a string "lower,upper", so we may have to deal with this
          var new_key = lat_array[0];
          // new_val: count
          var new_val = lat_array[1];
          if (new_key in current_interval) {
            current_interval[new_key] += new_val;
          } else {
            current_interval[new_key] = new_val;
          }
        });
      });
    });
    intervals.push({ timestamp: new Date(itimestamp * 1000), data: current_interval });
  });
  console.log(intervals);
//  d3.select("#chart")
//      .datum(data)
//      .call(flamegraph);
});

</script>

</body>
</html>
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>D3 v4 Flamegraph Tests</title>
  <!-- <script src="https://d3js.org/d3.v4.min.js"></script> -->
  <style>
    .chart {
      background:    lightgray;
      border:        1px solid black;
      min-width:      768px;
      min-height:     768px;
    }
    .stack-text {
      font-family:  "Verdana";
      font-size:    12px;
    }
  </style>
</head>
<body>

  <div class="chart"></div>
  <button onclick="simple_stacks()">Simple Kernel Stack</button>
  <button onclick="kernel_stacks2()">Kernel Stacks 2</button>

  <script type="text/javascript" src="d3v4/d3.min.js"></script>
  <script type="text/javascript">

    // Font related constants
    var fontsize    =   12,
        fontwidth   =   0.59; // Average width relative to fontsize

    var  width      =  768;
    var height      =  768;
    var cell_height =   18;

    // Color Theme
    var color_theme = "hot";
    // Background color gradient related
    // TODO: Set these based on the color theme
    var bgcolor1 = "#eeeeee",
        bgcolor2 = "#eeeeb0";

    function doSort(a,b) {
      return d3.ascending(a.name, b.name);
    }

    function background_gradient(svg, bgcolor1, bgcolor2, width, height) {
      var gradient = svg.append("defs")
        .append("linearGradient")
        .attr("id", "background")
        .attr("x1", "0%")
        .attr("y1", "0%")
        .attr("x2", "0%")
        .attr("y2", "100%")
        .attr("spreadMethod", "pad");

      gradient.append("stop")
        .attr("offset", "5%")
        .attr("stop-color", bgcolor1)
        .attr("stop-opacity", 1);

      gradient.append("stop")
        .attr("offset", "95%")
        .attr("stop-color", bgcolor2)
        .attr("stop-opacity", 1);

      svg.append("rect")
        .attr("width", width)
        .attr("height", height)
        .style("fill", "url(#background)");
    }

    function update(data) {

      var root = d3.hierarchy(data)
          .sort(doSort)
          .sum(function (d) { return d.children ? 0 : 1; })
        ;

      // xScale.domain([0, d3.max(root.children, function(root) { return root.data.value; })]).nice();
      xScale.domain([0, width]);

      var partition = d3.partition()
        .size([width, height])
        .padding(0);

      partition(root);

      var svg = d3.select('.chart')
        .append('svg')
        .attr('width', width)  // properly size the svg element to contain elems
        .attr('height', height);

      background_gradient(svg, bgcolor1, bgcolor2, width, height);

      var bars = svg
        .selectAll('g')
        .data(root.descendants())
        .enter()
        .append('g')
        .attr('transform',
          function (d, i) {
            // console.log(d);
            return 'translate(' + xScale(d.x0) + ',' +
                   (height - yScale(d.depth) - cell_height) + ')'; });


      var nodes = bars
        .append('rect')
        .attr('fill', function(d) {
          // return "white";
          return color(color_theme);
        })
        .attr('stroke', 'black')
        .attr("x", function(d) { return 0; })
        .attr("y", function(d) { return 0; })
        .attr("height", function(d) { return cell_height; })
        .attr("width", function(d) { return xScale(d.x1 - d.x0); });

      bars.append('text')
        .text(function(d,i) {
          var final_text_str;
          // Select the previous sibling rect for this text
          var rect = d3.select(this.previousSibling);
          var rect_width = rect.attr("width");

          var text_str = d.data.name;
          // how many characters will fit in the rect's available width?
          var chars_that_will_fit = rect_width / (fontsize * fontwidth);

          if (rect_width < (2 * fontsize * fontwidth)) {
            // nothing will fit
            final_text_str = "";
          } else if (text_str.length > chars_that_will_fit) {
            // console.log(text_str + " will not fit in only " + chars_that_will_fit + " spaces");
            // Just print what fits with a trailing ellipsis
            final_text_str = text_str.substring(0,chars_that_will_fit - 2 + 1) + "..";
          } else {
            // the whole string fits, no problem
            final_text_str = text_str;
          }

          return final_text_str;
        })
        .attr('y', cell_height - 3)
        .attr("class", "stack-text");
    }

    var xScale = d3.scaleLinear().range([0, width]),
        yScale = d3.scaleLinear().range([0, cell_height]);


    function simple_stacks() {
      d3.select('svg').remove();
      d3.json("kernel-stack-simple.json", function (error, data) {
        if (error) return console.warn("WE DIED: " + error);
        console.log(data);
        update(data);
      });
    }

    function kernel_stacks2() {
      d3.select('svg').remove();
      d3.json("kernel-stacks2.json", function (error, data) {
        if (error) return console.warn("WE DIED: " + error);
        console.log(data);
        update(data);
      });
    }

    function color(type, hash, name) {
      var v1, v2, v3;
      var r, g, b;

      // Random numbers between 0 and 1
      v1 = d3.randomUniform()();
      v2 = d3.randomUniform()();
      v3 = d3.randomUniform()();

      // Theme palettes
      if ((typeof type !== 'undefined') &&
          (type === "hot")) {
        r = 205 + Math.floor( 50 * v3);
        g =   0 + Math.floor(230 * v1);
        b =   0 + Math.floor( 55 * v2);
        return "rgb(" + r + "," + g + ","  + b + ")";
      }
      if ((typeof type !== 'undefined') &&
          (type === "mem")) {
        r =   0;
        g = 190 + Math.floor( 50 * v2);
        b =   0 + Math.floor(210 * v1);
        return "rgb(" + r + "," + g + ","  + b + ")";
      }
      if ((typeof type !== 'undefined') &&
          (type === "io")) {
        r =  80 + Math.floor(60 * v1);
        g =   r;
        b = 190 + Math.floor(55 * v2);
        return "rgb(" + r + "," + g + ","  + b + ")";
      }
    }
  </script>



</body>
</html>
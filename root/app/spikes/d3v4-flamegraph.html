<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>D3 v4 Flamegraph Tests</title>
  <!-- <script src="https://d3js.org/d3.v4.min.js"></script> -->
  <style>
    .chart {
      background:    lightgray;
      border:        1px solid black;
      min-width:      768px;
      min-height:     768px;
    }
    .stack-text {
      font-family:  "Verdana";
      font-size:    12px;
    }
  </style>
</head>
<body>

  <div class="chart"></div>
  <button onclick="simple_stacks()">Simple Kernel Stack</button>
  <button onclick="kernel_stacks2()">Kernel Stacks 2</button>
  <button onclick="stack_layout()">Layout Test</button>

  <script type="text/javascript" src="d3v4/d3.min.js"></script>
  <script type="text/javascript">

    // 18 pixel bottom margin to make room for informational banner
    var margin = { top: 0, right: 0, bottom: 18, left: 0 };

    // Font related constants
    var fontsize    =   12,
        fontwidth   =   0.59; // Average width relative to fontsize

    var  width      =  768 - margin.left - margin.right;
    var height      =  768 - margin.top - margin.bottom;
    var cell_height =   18;

    // Total value of all stack samples in root node
    var totalValue;

    // Color Theme
    var color_theme = "hot";
    // Background color gradient related
    // TODO: Set these based on the color theme
    var color_themes = {
      hot:     { bgcolor1: "#eeeeee", bgcolor2: "#eeeeb0" },
      mem:     { bgcolor1: "#eeeeee", bgcolor2: "#e0e0ff" },
      chain:   { bgcolor1: "#eeeeee", bgcolor2: "#e0e0ff" },
      io:      { bgcolor1: "#f8f8f8", bgcolor2: "#e8e8e8" },
      wakeup:  { bgcolor1: "#f8f8f8", bgcolor2: "#e8e8e8" },
      aqua:    { bgcolor1: "#f8f8f8", bgcolor2: "#e8e8e8" }
    }
    var bgcolor1 = "#eeeeee",
        bgcolor2 = "#eeeeb0";

    function doSort(a,b) {
      return d3.ascending(a.name, b.name);
    }

    function background_gradient(selection, bgcolor1, bgcolor2, width, height) {
      var gradient = selection.append("defs")
        .append("linearGradient")
        .attr("id", "background")
        .attr("x1", "0%")
        .attr("y1", "0%")
        .attr("x2", "0%")
        .attr("y2", "100%")
        .attr("spreadMethod", "pad");

      gradient.append("stop")
        .attr("offset", "5%")
        .attr("stop-color", bgcolor1)
        .attr("stop-opacity", 1);

      gradient.append("stop")
        .attr("offset", "95%")
        .attr("stop-color", bgcolor2)
        .attr("stop-opacity", 1);

      selection.append("rect")
        .attr("width", width)
        .attr("height", height)
        .style("fill", "url(#background)");
    }

    function update(data) {

      var root = d3.hierarchy(data)
          .sort(doSort)
          .sum(function (d) { return d.children ? 0 : d.value; })
        ;

      // xScale.domain([0, d3.max(root.children, function(root) { return root.data.value; })]).nice();
      xScale.domain([0, width]);

      var partition = d3.partition()
        .size([width, height])
        .padding(0);

      partition(root);

      // we can now determine the total value of the root node
      totalValue = root.data.value;
      console.log("totalValue: " + totalValue);

      var svg = d3.select('.chart')
        .append('svg')
          // properly size the svg element to contain elems
        .attr('width', width + margin.left + margin.right)
        .attr('height', height + margin.top + margin.bottom);

      var g_container =
        svg
          .append('g')
          .attr('transform','translate(' + margin.left + ',' + margin.top + ')');

      var banner_container =
        svg
          .append('g')
            .attr('transform','translate(0,' + (height) + ')')
            .attr("id", "banner_container")
          .append('rect')
            .attr("id", "banner_rect")
            .attr('fill', 'skyblue')
            .attr('stroke', 'green')
            .attr('x', 0)
            .attr('y', 0)
            .attr("height", cell_height)
            .attr("width", xScale(width))
        ;

      background_gradient(g_container, bgcolor1, bgcolor2, width, height);

      var bars = g_container
        .selectAll('g')
        .data(root.descendants())
        .enter()
        .append('g')
        .attr('transform',
          function (d, i) {
            // console.log(d);
            return 'translate(' + xScale(d.x0) + ',' +
                   (height - yScale(d.depth) - cell_height) + ')'; });


      var nodes = bars
        .append('rect')
        .attr('fill', function(d) {
          return color(color_theme);
        })
        .attr('stroke', 'black')
        .attr("x", function(d) { return 0; })
        .attr("y", function(d) { return 0; })
        .attr("height", function(d) { return cell_height; })
        .attr("width", function(d) { return xScale(d.x1 - d.x0); })
        .on('mouseover',nodeMouseOver);

      bars.append('text')
        .text(function(d,i) {
          var final_text_str;
          // Select the previous sibling rect for this text
          var rect = d3.select(this.previousSibling);
          var rect_width = rect.attr("width");

          var text_str = d.data.name;
          // how many characters will fit in the rect's available width?
          var chars_that_will_fit = rect_width / (fontsize * fontwidth);

          if (rect_width < (2 * fontsize * fontwidth)) {
            // nothing will fit
            final_text_str = "";
          } else if (text_str.length > chars_that_will_fit) {
            // Just print what fits with a trailing ellipsis
            final_text_str = text_str.substring(0,chars_that_will_fit - 2 + 1) + "..";
          } else {
            // the whole string fits, no problem
            final_text_str = text_str;
          }

          return final_text_str;
        })
        .attr('y', cell_height - 3)
        .attr("class", "stack-text");
    }

    var xScale = d3.scaleLinear().range([0, width]),
        yScale = d3.scaleLinear().range([0, cell_height]);


    function simple_stacks() {
      d3.select('svg').remove();
      d3.json("kernel-stack-simple.json", function (error, data) {
        if (error) return console.warn("WE DIED: " + error);
        // console.log(data);
        update(data);
      });
    }

    function kernel_stacks2() {
      d3.select('svg').remove();
      d3.json("kernel-stacks2.json", function (error, data) {
        if (error) return console.warn("WE DIED: " + error);
        // console.log(data);
        update(data);
      });
    }

    function stack_layout() {
      d3.select('svg').remove();
      d3.json("stack-layout.json", function (error, data) {
        if (error) return console.warn("WE DIED: " + error);
        // console.log(data);
        update(data);
      });
    }

    function nodeMouseOver(d) {
      console.log("in nodeMouseOver");
      console.log(d);
      var percentage = (100 * (d.value / totalValue)).toPrecision(3);
      var percentageString = percentage + "%";
      if (percentage < 0.1) {
        percentageString = "< 0.1%";
      }
      // d3.select('#banner_rect').select('text').remove();
      d3.select('#banner_container')
        .append("text")
        .attr("y", cell_height - 3)
        .text(percentageString);
    }

    function color(type, hash, name) {
      var v1, v2, v3;
      var r, g, b;

      // Random numbers between 0 and 1
      v1 = d3.randomUniform()();
      v2 = d3.randomUniform()();
      v3 = d3.randomUniform()();

      // Theme palettes
      if ((typeof type !== 'undefined') &&
          (type === "hot")) {
        r = 205 + Math.floor( 50 * v3);
        g =   0 + Math.floor(230 * v1);
        b =   0 + Math.floor( 55 * v2);
        return "rgb(" + r + "," + g + ","  + b + ")";
      }
      if ((typeof type !== 'undefined') &&
          (type === "mem")) {
        r =   0;
        g = 190 + Math.floor( 50 * v2);
        b =   0 + Math.floor(210 * v1);
        return "rgb(" + r + "," + g + ","  + b + ")";
      }
      if ((typeof type !== 'undefined') &&
          (type === "io")) {
        r =  80 + Math.floor(60 * v1);
        g =   r;
        b = 190 + Math.floor(55 * v2);
        return "rgb(" + r + "," + g + ","  + b + ")";
      }
    }
  </script>



</body>
</html>
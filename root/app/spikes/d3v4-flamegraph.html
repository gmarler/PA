<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>D3 v4 Flamegraph Tests</title>
  <!-- <script src="https://d3js.org/d3.v4.min.js"></script> -->
  <style>
    .hidden {
      visibility:    hidden;
    }

    .chart {
      background:    lightgray;
      border:        1px solid black;
      min-width:      768px;
      min-height:     768px;
    }
    .stack-text {
      font-family:    "Verdana";
      font-size:      12px;
      pointer-events: none;
      /* The following goes with the d3-flame-graph foreignObject concept */
      /*white-space:    nowrap;*/
      /*text-overflow:  ellipsis;*/
      /*overflow:       hidden;*/
      /*text-align:     left;*/
    }

    .fade {
      opacity: 0.6 !important;
    }

    /* Tool Tip Styling */
    .d3-flame-graph-tip {
      line-height: 1;
      font-family: Verdana;
      font-size: 12px;
      padding: 12px;
      background: rgba(0, 0, 0, 0.8);
      color: #fff;
      border-radius: 2px;
      pointer-events: none;
    }

    /* Creates a small triangle extender for the tooltip */
    .d3-flame-graph-tip:after {
      box-sizing: border-box;
      display: inline;
      font-size: 10px;
      width: 100%;
      line-height: 1;
      color: rgba(0, 0, 0, 0.8);
      position: absolute;
      pointer-events: none;
    }

    /* Northward tooltips */
    .d3-flame-graph-tip.n:after {
      content: "\25BC";
      margin: -1px 0 0 0;
      top: 100%;
      left: 0;
      text-align: center;
    }

    /* Eastward tooltips */
    .d3-flame-graph-tip.e:after {
      content: "\25C0";
      margin: -4px 0 0 0;
      top: 50%;
      left: -8px;
    }

    /* Southward tooltips */
    .d3-flame-graph-tip.s:after {
      content: "\25B2";
      margin: 0 0 1px 0;
      top: -8px;
      left: 0;
      text-align: center;
    }

    /* Westward tooltips */
    .d3-flame-graph-tip.w:after {
      content: "\25B6";
      margin: -4px 0 0 -1px;
      top: 50%;
      left: 100%;
    }
  </style>
</head>
<body>

  <div class="chart"></div>
  <button onclick="simple_stacks()">Simple Kernel Stack</button>
  <button onclick="kernel_stacks2()">Kernel Stacks 2</button>
  <button onclick="stack_layout()">Layout Test</button>




  <!-- This is D3 v4 -->
  <script type="text/javascript" src="../../bower_components/d3/d3.min.js"></script>

  <!-- and our Javascript spike for Flame Graph -->
  <script type="text/javascript">

    // 18 pixel bottom margin to make room for informational banner
    var margin = { top: 0, right: 0, bottom: 18, left: 0 };

    // Font related constants
    var fontsize    =   12,
        fontwidth   =   0.59; // Average width relative to fontsize

    var  width      =  768 - margin.left - margin.right;
    var height      =  768 - margin.top - margin.bottom;
    var cell_height =   18;
    var sort        =  true,
        tooltip     =  true,
        selection   =  null,
        title       =    "",
        reversed    =  false;

    // Total value of all stack samples in root node
    var totalValue;

    // Color Theme
    var color_theme = "hot";

    var color_themes = {
      hot:     { bgcolor1: "#eeeeee", bgcolor2: "#eeeeb0" },
      mem:     { bgcolor1: "#eeeeee", bgcolor2: "#e0e0ff" },
      chain:   { bgcolor1: "#eeeeee", bgcolor2: "#e0e0ff" },
      io:      { bgcolor1: "#f8f8f8", bgcolor2: "#e8e8e8" },
      wakeup:  { bgcolor1: "#f8f8f8", bgcolor2: "#e8e8e8" },
      aqua:    { bgcolor1: "#f8f8f8", bgcolor2: "#e8e8e8" }
    };
    // Background color gradient related
    // TODO: Set these based on the color theme
    var bgcolor1 = "#eeeeee",
        bgcolor2 = "#eeeeb0";

    function doSort(a,b) {
      // If sort is a function, use it
      if (typeof sort === 'function') {
        return sort(a,b);
      }
      // Otherwise, if sort is truthy, use d3.ascending
      else if (sort) {
        return d3.ascending(a.name, b.name);
      }
      // Otherwise, do nothing
      else { return 0; }
    }

    function background_gradient(selection, bgcolor1, bgcolor2, width, height) {
      var gradient = selection.append("defs")
        .append("linearGradient")
        .attr("id", "background")
        .attr("x1", "0%")
        .attr("y1", "0%")
        .attr("x2", "0%")
        .attr("y2", "100%")
        .attr("spreadMethod", "pad");

      gradient.append("stop")
        .attr("offset", "5%")
        .attr("stop-color", bgcolor1)
        .attr("stop-opacity", 1);

      gradient.append("stop")
        .attr("offset", "95%")
        .attr("stop-color", bgcolor2)
        .attr("stop-opacity", 1);

      selection.append("rect")
        .attr("width", width)
        .attr("height", height)
        .style("fill", "url(#background)");
    }

    function update(data) {

      var root = d3.hierarchy(data)
          .sort(doSort)
          .sum(function (d) { return d.children ? 0 : d.value; })
        ;

      // Put a unique ID on each datum
      root.each(
        function(node) {
          node.data.uniqueID = makeId();
        }
      );


      var partition = d3.partition()
        // This implicitly scales x0,y0,x1,y1
        .size([width, height])
        .padding(0);

      partition(root);

      // We can now determine the proper scale domain(s)
      // xScale.domain([0, d3.max(root.children, function(root) { return root.data.value; })]).nice();
      console.log("X Domain MAX:" + root.data.value);
      // xScale.domain([0, width]);
      xScale.domain([0, root.data.value]);

      // we can now determine the total value of the root node
      totalValue = root.data.value;
      console.log("totalValue: " + totalValue);

      var svg = d3.select('.chart')
        .append('svg')
          // properly size the svg element to contain elems
        .attr('width', width + margin.left + margin.right)
        .attr('height', height + margin.top + margin.bottom);

      var g_container =
        svg
          .append('g')
          .attr('transform','translate(' + margin.left + ',' + margin.top + ')');

      var banner_container =
        svg
          .append('g')
            .attr('transform','translate(0,' + (height) + ')')
            .attr("id", "banner_container")
          .append('rect')
            .attr("id", "banner_rect")
            .attr('fill', 'skyblue')
            .attr('stroke', 'green')
            .attr('x', 0)
            .attr('y', 0)
            .attr("height", cell_height)
            .attr("width",  width)
        ;

      background_gradient(g_container, bgcolor1, bgcolor2, width, height);

      var bars = g_container
        .selectAll('g')
        .data(root.descendants())
        .enter()
        .append('g')
          .attr('transform',
            function (d, i) {
              console.log(d, this);
              // console.log("BARS: d.x0: " + d.x0 + ", scaled d.x0: " + xScale(d.x0) );
              return 'translate(' + d.x0 + ',' +
                     (height - yScale(d.depth) - cell_height) + ')';
            }
          )
          .attr("id", function(d) { return d.data.uniqueID; } )
          .on('click',  nodeZoom);


      var nodes = bars
        .append('rect')
        .attr('fill', function(d) {
          return color(color_theme);
        })
        .attr('stroke', 'black')
        .attr("x", function(d) { return 0; })
        .attr("y", function(d) { return 0; })
        .attr("height", function(d) { return cell_height; })
        .attr("width", function(d) { // return xScale(d.x1 - d.x0);
                                     return (d.x1 - d.x0);})
        .on('mouseover',nodeMouseOver)
        .on('mouseout', nodeMouseOut);

      bars.append('text')
        .text(function(d,i) {
          var final_text_str;
          // Select the previous sibling rect for this text
           var rect = d3.select(this.previousSibling);
           var rect_width = rect.attr("width");

          var text_str = d.data.name;
          // how many characters will fit in the rect's available width?
          var chars_that_will_fit = rect_width / (fontsize * fontwidth);

          if (rect_width < (2 * fontsize * fontwidth)) {
            // nothing will fit
            final_text_str = "";
          } else if (text_str.length > chars_that_will_fit) {
            // Just print what fits with a trailing ellipsis
            final_text_str = text_str.substring(0,chars_that_will_fit - 2) + "..";
          } else {
            // the whole string fits, no problem
            final_text_str = text_str;
          }

          return final_text_str;
        })
        .attr('y', cell_height - 3)
        .attr('x', 3)
        .attr("class", "stack-text");
    }

    var xScale = d3.scaleLinear().range([0, width]),
        yScale = d3.scaleLinear().range([0, cell_height]);


    function display_chart(chart_data) {
      // Eliminate existing SVG, if any
      d3.select('svg').remove();
      d3.json(chart_data, function (error, data) {
        if (error) return console.warn("WE DIED: " + error);
        // console.log(data);
        update(data);
      });
    }

    function simple_stacks() {
      display_chart("kernel-stack-simple.json");
    }

    function kernel_stacks2() {
      display_chart("kernel-stacks2.json");
    }

    function stack_layout() {
      display_chart("stack-layout.json");
    }

    function nodeMouseOver(d) {
      d3.select(this).attr('opacity', .25);
      // console.log(d);
      var percentage = (100 * (d.value / totalValue)).toPrecision(3);
      var percentageString = percentage + "%";
      if (percentage < 0.1) {
        percentageString = "< 0.1%";
      }
      var wholeString = "Function: " + d.data.name + " (" + d.data.value + " samples, " + percentageString + ")";
      // d3.select('#banner_rect').select('text').remove();
      d3.select('#banner_container')
        .append("text")
        .attr("y", cell_height - 3)
        .text(wholeString);
    }


    function nodeMouseOut(d) {
      d3.select(this).attr('opacity', 1);
      d3.select('#banner_container')
        .selectAll('text').remove();
    }

    function color(type, hash, name) {
      var v1, v2, v3;
      var r, g, b;

      // Random numbers between 0 and 1
      v1 = d3.randomUniform()();
      v2 = d3.randomUniform()();
      v3 = d3.randomUniform()();

      // Theme palettes
      if ((typeof type !== 'undefined') &&
          (type === "hot")) {
        r = 205 + Math.floor( 50 * v3);
        g =   0 + Math.floor(230 * v1);
        b =   0 + Math.floor( 55 * v2);
        return "rgb(" + r + "," + g + ","  + b + ")";
      }
      if ((typeof type !== 'undefined') &&
          (type === "mem")) {
        r =   0;
        g = 190 + Math.floor( 50 * v2);
        b =   0 + Math.floor(210 * v1);
        return "rgb(" + r + "," + g + ","  + b + ")";
      }
      if ((typeof type !== 'undefined') &&
          (type === "io")) {
        r =  80 + Math.floor(60 * v1);
        g =   r;
        b = 190 + Math.floor(55 * v2);
        return "rgb(" + r + "," + g + ","  + b + ")";
      }


    }


    function nodeClicked(d) {


      // nodeZoom(d);

//      xScale.domain([d.x0, d.x0 + d.x1]);
//      // yScale.domain([d.y0, 1]).range([d.y0 ? 20 : 0, height]);
//
//      var kx = width / (1 - d.x0);
//      var ky = height / d.y0;
//
//      var g = d3.select('svg.g');
//
//      var t = g.attr("transform",
//        function(d) { return "translate(" + d.x0 + "," + d.y0 + ")"; });
//
//      t.select("rect")
//        .attr("width", d.x1 * kx);
//
//      t.select("text")
//        .attr("transform", function(d) {
//          return "translate(0," + d.y1 * ky / 2 + ")";
//        });
//
//      var nodes = d3.selectAll("svg>g>g>rect")
//      // .transition()
//      // .duration(750)
//        .attr("x", function(d) { console.log(d);
//          return xScale(d.x0);
//          // return d.x0;
//        })
//        //.attr("y", function(d) { return yScale(d.y0); })
//        // .attr("height", function(d) { return yScale(d.y1 + d.y0) - yScale(d.y1); })
//        .attr("width", function(d) {
//          // return xScale(d.x1 - d.x0) - xScale(d.x1);
//          return (d.x1 - d.x0);
//        });
    }

    function nodeZoom(datum, index, nodes) {
      console.log("THIS:");
      console.log(this);
      console.log(datum);
      // squirrel away DOM element 'this' for later use
      var dom_g = this;

      var ancestors = datum.ancestors();

//      console.log("ANCESTORS:");
//      ancestors.forEach(
//        function (node, i) {
//          if (i == 0) { return; }
//          console.log(node.data.name);
//        }
//      );

      var descendants = datum.descendants();

//      console.log("DESCENDANTS:");
//      descendants.forEach(
//        function (node, i) {
//          if (i == 0) { return; }
//          console.log(node.data.name);
//        }
//      );


      var siblings = getSiblings(datum);
      console.log("SIBLINGS:");
      siblings.forEach(
        function (node, i) {
          console.log(node.data.name);
          console.log("UNIQUE ID:", node.data.uniqueID);

          // Disappear each sibling
          d3
            .select("#" + node.data.uniqueID)
            .selectAll("*")
            .classed("hidden","true");
        }
      );
      // TODO:
      // Also need to disappear any nodes that are "above" this one
      // (depth is < this node's depth), AND aren't an ancestor of this node.

      ancestors.forEach(
        function (node, i) {
          if (i == 0) { return; }
          d3
            .select("#" + node.data.uniqueID)
            .selectAll("*")
            .classed("fade", "true");
        }
      );

      // TODO: Scale ancestors to 100%, if they aren't already
      //       We get this node included for free in ancestors

      // TODO: Scale the descendants

//      hideSiblings(datum);
//      show(datum);
//      fadeAncestors(datum);
//      update();
    }

    function hideSiblings(d) {
      var siblings = getSiblings(d);

      siblings.forEach(
        function(s) {
          hide(s);
        }
      );
      if (d.parent) {
        hideSiblings(d.parent);
      }
    }

    function getSiblings(d) {
      var oldsiblings = [];
      var newsiblings = [];
      var depth    = d.depth;
      var myID     = d.data.uniqueID;

      console.log("Selecting svg>g>g");
      newsiblings = d3.selectAll("svg>g>g")
        .filter(function(d) { return (depth == d.depth) && (myID != d.data.uniqueID);
        })
        .data();

      if (d.parent) {
        var me = d.parent.children.indexOf(d);
        oldsiblings = d.parent.children.slice(0);
        oldsiblings.splice(me, 1);
      }

      return newsiblings;
    }

    function hide(d) {
      if (!d.original) {
        d.original = d.value;
      }
      d.value = 0;
      if (d.children) {
        d.children.forEach(hide);
      }
    }

    function show(d) {
      d.fade = false;
      if (d.original) {
        d.value = d.original;
      }
      if (d.children) {
        d.children.forEach(show);
      }
    }

    function fadeAncestors(d) {
      if (d.parent) {
        d.parent.fade = true;
        fadeAncestors(d.parent);
      }
    }

    function makeId(prefix) {
      // HTML id's must begin with a letter of some sort
      prefix || (prefix = 'X');
      return prefix + (Math.random() * 1e16).toFixed(0);
    }
  </script>



</body>
</html>